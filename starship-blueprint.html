<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starship Blueprint</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a0f;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #webcam {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            border: 2px solid rgba(0, 255, 100, 0.3);
            transform: scaleX(-1);
            z-index: 100;
            object-fit: cover;
        }

        #canvas {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            z-index: 101;
            pointer-events: none;
            transform: scaleX(-1);
        }

        /* Hand cursor circles */
        .hand-cursor {
            position: fixed;
            width: 60px;
            height: 60px;
            border: 3px solid #00ff66;
            border-radius: 50%;
            pointer-events: none;
            z-index: 200;
            transform: translate(-50%, -50%);
            transition: transform 0.05s, opacity 0.2s, border-color 0.2s, box-shadow 0.2s;
            opacity: 0;
        }

        .hand-cursor.visible {
            opacity: 1;
        }

        .hand-cursor.pinching {
            border-color: #00ffaa;
            box-shadow: 0 0 30px rgba(0, 255, 170, 0.6);
            transform: translate(-50%, -50%) scale(0.7);
        }

        .hand-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: #00ff66;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .hand-cursor.pinching::after {
            background: #00ffaa;
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 12px;
            font-size: 14px;
        }

        #instructions h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #00ff66;
        }

        #instructions p {
            margin: 8px 0;
            color: rgba(255, 255, 255, 0.8);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 300;
            text-align: center;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 255, 102, 0.2);
            border-top-color: #00ff66;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #zoom-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff66;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
        }

        #zoom-indicator.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        <div>Loading...</div>
    </div>

    <div id="container"></div>

    <video id="webcam" autoplay playsinline></video>
    <canvas id="canvas"></canvas>

    <div class="hand-cursor" id="cursor-left"></div>
    <div class="hand-cursor" id="cursor-right"></div>

    <div id="zoom-indicator">ZOOM</div>

    <div id="instructions">
        <h2>üöÄ Starship Blueprint</h2>
        <p>ü§è <strong>Pinch</strong> to grab</p>
        <p>‚úã <strong>Move</strong> while pinching to spin</p>
        <p>ü§èü§è <strong>Two hands</strong> pinch + spread to zoom</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <script>
        // Three.js
        let scene, camera, renderer, rocketGroup;
        let targetRotX = 0, targetRotY = 0;
        let currentRotX = 0, currentRotY = 0;
        let targetZoom = 6, currentZoom = 6;

        // Hand state
        let hands = { left: null, right: null };
        let lastPinchPos = null;
        let lastTwoHandDist = null;

        function createHoloMaterial(color = 0x00aaff) {
            return new THREE.MeshBasicMaterial({
                color: color,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
        }

        function initScene() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 6;
            camera.position.y = 1;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0a0a0f);
            document.getElementById('container').appendChild(renderer.domElement);

            // Stars
            const starGeo = new THREE.BufferGeometry();
            const starPos = new Float32Array(2000 * 3);
            for (let i = 0; i < 2000 * 3; i += 3) {
                starPos[i] = (Math.random() - 0.5) * 100;
                starPos[i + 1] = (Math.random() - 0.5) * 100;
                starPos[i + 2] = (Math.random() - 0.5) * 100 - 20;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0x4488ff, size: 0.15 }));
            scene.add(stars);

            // Rocket group
            rocketGroup = new THREE.Group();

            // Nose cone
            const nose = new THREE.Mesh(
                new THREE.ConeGeometry(0.5, 1.5, 12),
                createHoloMaterial(0x00ffaa)
            );
            nose.position.y = 4;
            rocketGroup.add(nose);

            // Upper body
            const upper = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, 2, 12),
                createHoloMaterial()
            );
            upper.position.y = 2.5;
            rocketGroup.add(upper);

            // Middle tank
            const middle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, 2.5, 12),
                createHoloMaterial()
            );
            middle.position.y = 0.5;
            rocketGroup.add(middle);

            // Lower body
            const lower = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.6, 1.5, 12),
                createHoloMaterial()
            );
            lower.position.y = -1.25;
            rocketGroup.add(lower);

            // Engine section
            const engine = new THREE.Mesh(
                new THREE.CylinderGeometry(0.6, 0.55, 0.8, 12),
                createHoloMaterial(0x00ffaa)
            );
            engine.position.y = -2.4;
            rocketGroup.add(engine);

            // Engines (3 cones)
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const eng = new THREE.Mesh(
                    new THREE.ConeGeometry(0.15, 0.5, 8),
                    createHoloMaterial(0x00ff66)
                );
                eng.position.x = Math.cos(angle) * 0.3;
                eng.position.z = Math.sin(angle) * 0.3;
                eng.position.y = -3;
                eng.rotation.x = Math.PI;
                rocketGroup.add(eng);
            }

            // Fins (4)
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                const fin = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 1, 0.05),
                    createHoloMaterial(0x00aaff)
                );
                fin.position.x = Math.cos(angle) * 0.7;
                fin.position.z = Math.sin(angle) * 0.7;
                fin.position.y = -2;
                fin.rotation.y = -angle;
                rocketGroup.add(fin);
            }

            // Add edges for glow effect
            rocketGroup.children.forEach(child => {
                if (child.geometry) {
                    const edges = new THREE.EdgesGeometry(child.geometry);
                    const line = new THREE.LineSegments(
                        edges,
                        new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 })
                    );
                    line.position.copy(child.position);
                    line.rotation.copy(child.rotation);
                    rocketGroup.add(line);
                }
            });

            scene.add(rocketGroup);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Smooth interpolation
            currentRotX += (targetRotX - currentRotX) * 0.1;
            currentRotY += (targetRotY - currentRotY) * 0.1;
            currentZoom += (targetZoom - currentZoom) * 0.1;

            rocketGroup.rotation.x = currentRotX;
            rocketGroup.rotation.y = currentRotY;
            camera.position.z = currentZoom;

            renderer.render(scene, camera);
        }

        async function initHandTracking() {
            const video = document.getElementById('webcam');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const loading = document.getElementById('loading');
            const cursorLeft = document.getElementById('cursor-left');
            const cursorRight = document.getElementById('cursor-right');
            const zoomIndicator = document.getElementById('zoom-indicator');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                video.srcObject = stream;
                await video.play();
            } catch (err) {
                loading.innerHTML = '‚ùå Camera access needed';
                return;
            }

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            const mpHands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            mpHands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            mpHands.onResults((results) => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                hands.left = null;
                hands.right = null;

                if (results.multiHandLandmarks && results.multiHandedness) {
                    for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                        const landmarks = results.multiHandLandmarks[i];
                        const label = results.multiHandedness[i].label;

                        // Draw on mini canvas
                        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: '#00ff66', lineWidth: 2 });

                        // MediaPipe mirrors: "Left" = right hand visually
                        if (label === 'Left') {
                            hands.right = landmarks;
                        } else {
                            hands.left = landmarks;
                        }
                    }
                }

                // Update cursors and process gestures
                processHands(cursorLeft, cursorRight, zoomIndicator);
            });

            loading.style.display = 'none';

            const cam = new Camera(video, {
                onFrame: async () => await mpHands.send({ image: video }),
                width: 640,
                height: 480
            });
            cam.start();
        }

        function getPinchCenter(hand) {
            const thumb = hand[4];
            const index = hand[8];
            return {
                x: (thumb.x + index.x) / 2,
                y: (thumb.y + index.y) / 2
            };
        }

        function getPinchDistance(hand) {
            const thumb = hand[4];
            const index = hand[8];
            return Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
        }

        function processHands(cursorLeft, cursorRight, zoomIndicator) {
            const leftHand = hands.left;
            const rightHand = hands.right;

            // Update left cursor
            if (leftHand) {
                const pos = getPinchCenter(leftHand);
                const isPinching = getPinchDistance(leftHand) < 0.07;
                cursorLeft.style.left = ((1 - pos.x) * window.innerWidth) + 'px';
                cursorLeft.style.top = (pos.y * window.innerHeight) + 'px';
                cursorLeft.classList.add('visible');
                cursorLeft.classList.toggle('pinching', isPinching);
            } else {
                cursorLeft.classList.remove('visible', 'pinching');
            }

            // Update right cursor
            if (rightHand) {
                const pos = getPinchCenter(rightHand);
                const isPinching = getPinchDistance(rightHand) < 0.07;
                cursorRight.style.left = ((1 - pos.x) * window.innerWidth) + 'px';
                cursorRight.style.top = (pos.y * window.innerHeight) + 'px';
                cursorRight.classList.add('visible');
                cursorRight.classList.toggle('pinching', isPinching);
            } else {
                cursorRight.classList.remove('visible', 'pinching');
            }

            // Gesture logic
            const leftPinching = leftHand && getPinchDistance(leftHand) < 0.07;
            const rightPinching = rightHand && getPinchDistance(rightHand) < 0.07;

            // Two hands pinching = zoom
            if (leftPinching && rightPinching) {
                const leftPos = getPinchCenter(leftHand);
                const rightPos = getPinchCenter(rightHand);
                const dist = Math.sqrt(
                    Math.pow(leftPos.x - rightPos.x, 2) +
                    Math.pow(leftPos.y - rightPos.y, 2)
                );

                if (lastTwoHandDist !== null) {
                    const delta = (lastTwoHandDist - dist) * 15;
                    targetZoom = Math.max(3, Math.min(12, targetZoom + delta));
                }

                lastTwoHandDist = dist;
                lastPinchPos = null; // Disable rotation during zoom

                zoomIndicator.classList.add('visible');
            }
            // Single hand pinching = rotate
            else if (leftPinching || rightPinching) {
                const hand = leftPinching ? leftHand : rightHand;
                const pos = getPinchCenter(hand);

                if (lastPinchPos !== null) {
                    const deltaX = (pos.x - lastPinchPos.x) * 5;
                    const deltaY = (pos.y - lastPinchPos.y) * 5;
                    targetRotY -= deltaX;
                    targetRotX += deltaY;
                }

                lastPinchPos = pos;
                lastTwoHandDist = null;

                zoomIndicator.classList.remove('visible');
            }
            // No pinch = reset
            else {
                lastPinchPos = null;
                lastTwoHandDist = null;
                zoomIndicator.classList.remove('visible');
            }
        }

        initScene();
        animate();
        initHandTracking();
    </script>
</body>
</html>
