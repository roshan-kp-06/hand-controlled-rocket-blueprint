<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Control Solar System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #webcam {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            border: 2px solid rgba(0, 255, 100, 0.3);
            transform: scaleX(-1);
            z-index: 100;
            object-fit: cover;
        }

        #canvas {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            z-index: 101;
            pointer-events: none;
            transform: scaleX(-1);
        }

        .hand-cursor {
            position: fixed;
            width: 50px;
            height: 50px;
            border: 3px solid #00ff66;
            border-radius: 50%;
            pointer-events: none;
            z-index: 200;
            transform: translate(-50%, -50%);
            transition: transform 0.05s, border-color 0.15s, box-shadow 0.15s;
            opacity: 0;
        }

        .hand-cursor.visible {
            opacity: 1;
        }

        .hand-cursor.pinching {
            border-color: #00ffaa;
            box-shadow: 0 0 30px rgba(0, 255, 170, 0.6);
            transform: translate(-50%, -50%) scale(0.6);
        }

        .hand-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: #00ff66;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 12px;
            font-size: 14px;
        }

        #instructions h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #00ff66;
        }

        #instructions p {
            margin: 8px 0;
            color: rgba(255, 255, 255, 0.8);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 300;
            text-align: center;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 255, 102, 0.2);
            border-top-color: #00ff66;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #planet-label {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
            text-shadow: 0 0 20px currentColor;
            letter-spacing: 4px;
        }

        #planet-label.visible {
            opacity: 1;
        }

        #mode-indicator {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff66;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
            letter-spacing: 2px;
        }

        #mode-indicator.visible {
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        <div>Loading Solar System...</div>
    </div>

    <div id="container"></div>

    <video id="webcam" autoplay playsinline></video>
    <canvas id="canvas"></canvas>

    <div class="hand-cursor" id="cursor"></div>

    <div id="planet-label"></div>
    <div id="mode-indicator"></div>

    <div id="instructions">
        <h2>üåå Solar System</h2>
        <p>ü§è <strong>Pinch planet</strong> to grab & spin</p>
        <p>ü§è <strong>Pinch space</strong> + move to zoom</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <script>
        let scene, camera, renderer;
        let planets = [];
        let selectedPlanet = null;
        let solarSystemGroup;

        // Camera controls
        let targetCamY = 30, targetCamZ = 50;
        let currentCamY = 30, currentCamZ = 50;

        // Hand tracking
        let lastPinchPos = null;
        let isZooming = false;

        const planetData = [
            { name: 'Sun', radius: 3, distance: 0, color: 0xffdd00, emissive: true, rotationSpeed: 0.001 },
            { name: 'Mercury', radius: 0.4, distance: 6, color: 0x8c7853, rotationSpeed: 0.01 },
            { name: 'Venus', radius: 0.6, distance: 9, color: 0xffc649, rotationSpeed: 0.008 },
            { name: 'Earth', radius: 0.65, distance: 12, color: 0x6b93d6, rotationSpeed: 0.01 },
            { name: 'Mars', radius: 0.5, distance: 16, color: 0xc1440e, rotationSpeed: 0.009 },
            { name: 'Jupiter', radius: 1.8, distance: 24, color: 0xd8ca9d, rotationSpeed: 0.02 },
            { name: 'Saturn', radius: 1.5, distance: 32, color: 0xead6b8, hasRings: true, rotationSpeed: 0.018 },
            { name: 'Uranus', radius: 1.0, distance: 40, color: 0xd1e7e7, rotationSpeed: 0.012 },
            { name: 'Neptune', radius: 0.95, distance: 48, color: 0x5b5ddf, rotationSpeed: 0.011 }
        ];

        function createPlanetTexture(color, name) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            const baseColor = '#' + color.toString(16).padStart(6, '0');
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, 512, 256);

            // Add texture variation
            for (let i = 0; i < 30; i++) {
                ctx.beginPath();
                ctx.arc(Math.random() * 512, Math.random() * 256, Math.random() * 20 + 5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, 0.05)`;
                ctx.fill();
            }

            if (name === 'Earth') {
                ctx.fillStyle = '#2d5a27';
                ctx.beginPath();
                ctx.ellipse(150, 100, 50, 35, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(350, 90, 70, 45, 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(380, 170, 35, 45, 0, 0, Math.PI * 2);
                ctx.fill();
                // Ice caps
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, 512, 20);
                ctx.fillRect(0, 236, 512, 20);
            }

            if (name === 'Jupiter') {
                for (let y = 0; y < 256; y += 15) {
                    ctx.fillStyle = y % 30 === 0 ? 'rgba(139, 90, 43, 0.4)' : 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(0, y, 512, 8);
                }
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.ellipse(200, 140, 35, 20, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            if (name === 'Saturn') {
                for (let y = 0; y < 256; y += 20) {
                    ctx.fillStyle = 'rgba(139, 119, 101, 0.3)';
                    ctx.fillRect(0, y, 512, 10);
                }
            }

            return new THREE.CanvasTexture(canvas);
        }

        function initScene() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 50);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000008);
            document.getElementById('container').appendChild(renderer.domElement);

            // Stars
            const starGeo = new THREE.BufferGeometry();
            const starPos = new Float32Array(5000 * 3);
            for (let i = 0; i < 5000 * 3; i += 3) {
                starPos[i] = (Math.random() - 0.5) * 500;
                starPos[i + 1] = (Math.random() - 0.5) * 500;
                starPos[i + 2] = (Math.random() - 0.5) * 500;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 }));
            scene.add(stars);

            solarSystemGroup = new THREE.Group();

            planetData.forEach((data) => {
                const group = new THREE.Group();

                const geometry = new THREE.SphereGeometry(data.radius, 32, 32);
                let material;

                if (data.emissive) {
                    material = new THREE.MeshBasicMaterial({
                        map: createPlanetTexture(data.color, data.name),
                        color: data.color
                    });
                } else {
                    material = new THREE.MeshStandardMaterial({
                        map: createPlanetTexture(data.color, data.name),
                        roughness: 0.8,
                        metalness: 0.1
                    });
                }

                const mesh = new THREE.Mesh(geometry, material);
                group.add(mesh);

                if (data.hasRings) {
                    const ringGeo = new THREE.RingGeometry(2, 3, 64);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: 0xc9b896,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.6
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 2.5;
                    group.add(ring);
                }

                group.position.x = data.distance;
                group.userData = {
                    name: data.name,
                    radius: data.radius,
                    rotationSpeed: data.rotationSpeed,
                    mesh: mesh
                };

                solarSystemGroup.add(group);
                planets.push(group);

                // Orbit line
                if (data.distance > 0) {
                    const orbitGeo = new THREE.BufferGeometry();
                    const orbitPoints = [];
                    for (let i = 0; i <= 64; i++) {
                        const angle = (i / 64) * Math.PI * 2;
                        orbitPoints.push(Math.cos(angle) * data.distance, 0, Math.sin(angle) * data.distance);
                    }
                    orbitGeo.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints, 3));
                    const orbit = new THREE.Line(orbitGeo, new THREE.LineBasicMaterial({ color: 0x333344, transparent: true, opacity: 0.3 }));
                    solarSystemGroup.add(orbit);
                }
            });

            scene.add(solarSystemGroup);

            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);

            const sunLight = new THREE.PointLight(0xffffff, 2, 200);
            scene.add(sunLight);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            planets.forEach(planet => {
                planet.children[0].rotation.y += planet.userData.rotationSpeed;
            });

            currentCamY += (targetCamY - currentCamY) * 0.08;
            currentCamZ += (targetCamZ - currentCamZ) * 0.08;

            camera.position.set(0, currentCamY, currentCamZ);
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        function findNearestPlanet(screenX, screenY) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(
                (screenX / window.innerWidth) * 2 - 1,
                -(screenY / window.innerHeight) * 2 + 1
            );

            raycaster.setFromCamera(mouse, camera);

            // Direct raycast hit
            for (const planet of planets) {
                const intersects = raycaster.intersectObject(planet.children[0]);
                if (intersects.length > 0) {
                    return planet;
                }
            }

            // Proximity check
            let nearest = null;
            let nearestDist = Infinity;

            planets.forEach(planet => {
                const pos = planet.position.clone().project(camera);
                const px = (pos.x + 1) / 2 * window.innerWidth;
                const py = (-pos.y + 1) / 2 * window.innerHeight;
                const dist = Math.sqrt(Math.pow(px - screenX, 2) + Math.pow(py - screenY, 2));

                const threshold = 50 + planet.userData.radius * 15;
                if (dist < threshold && dist < nearestDist) {
                    nearestDist = dist;
                    nearest = planet;
                }
            });

            return nearest;
        }

        async function initHandTracking() {
            const video = document.getElementById('webcam');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const loading = document.getElementById('loading');
            const cursor = document.getElementById('cursor');
            const planetLabel = document.getElementById('planet-label');
            const modeIndicator = document.getElementById('mode-indicator');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                video.srcObject = stream;
                await video.play();
            } catch (err) {
                loading.innerHTML = '‚ùå Camera access needed';
                return;
            }

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            const mpHands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            mpHands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            mpHands.onResults((results) => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];

                    drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: '#00ff66', lineWidth: 2 });

                    processHand(landmarks, cursor, planetLabel, modeIndicator);
                } else {
                    cursor.classList.remove('visible', 'pinching');
                    planetLabel.classList.remove('visible');
                    modeIndicator.classList.remove('visible');
                    selectedPlanet = null;
                    isZooming = false;
                    lastPinchPos = null;
                }
            });

            loading.style.display = 'none';

            const cam = new Camera(video, {
                onFrame: async () => await mpHands.send({ image: video }),
                width: 640,
                height: 480
            });
            cam.start();
        }

        function processHand(landmarks, cursor, planetLabel, modeIndicator) {
            const thumb = landmarks[4];
            const index = landmarks[8];

            const pinchX = (thumb.x + index.x) / 2;
            const pinchY = (thumb.y + index.y) / 2;
            const pinchDist = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));

            const screenX = (1 - pinchX) * window.innerWidth;
            const screenY = pinchY * window.innerHeight;
            const isPinching = pinchDist < 0.07;

            // Update cursor
            cursor.style.left = screenX + 'px';
            cursor.style.top = screenY + 'px';
            cursor.classList.add('visible');
            cursor.classList.toggle('pinching', isPinching);

            const nearPlanet = findNearestPlanet(screenX, screenY);

            if (isPinching) {
                if (lastPinchPos === null) {
                    // Just started pinching - decide mode
                    if (nearPlanet) {
                        selectedPlanet = nearPlanet;
                        isZooming = false;
                    } else {
                        selectedPlanet = null;
                        isZooming = true;
                    }
                }

                if (lastPinchPos) {
                    const deltaX = (pinchX - lastPinchPos.x) * 6;
                    const deltaY = (pinchY - lastPinchPos.y) * 6;

                    if (selectedPlanet) {
                        // Spin the planet
                        selectedPlanet.children[0].rotation.y -= deltaX;
                        selectedPlanet.children[0].rotation.x += deltaY;
                    } else if (isZooming) {
                        // Zoom with vertical movement
                        targetCamZ = Math.max(15, Math.min(100, targetCamZ + deltaY * 20));
                        targetCamY = targetCamZ * 0.6;
                    }
                }

                lastPinchPos = { x: pinchX, y: pinchY };

                // Update labels
                if (selectedPlanet) {
                    const data = planetData.find(p => p.name === selectedPlanet.userData.name);
                    planetLabel.textContent = selectedPlanet.userData.name;
                    planetLabel.style.color = '#' + data.color.toString(16).padStart(6, '0');
                    planetLabel.classList.add('visible');
                    modeIndicator.textContent = 'SPINNING';
                    modeIndicator.classList.add('visible');
                } else {
                    planetLabel.classList.remove('visible');
                    modeIndicator.textContent = 'ZOOMING';
                    modeIndicator.classList.add('visible');
                }
            } else {
                // Not pinching - show hover label
                lastPinchPos = null;
                selectedPlanet = null;
                isZooming = false;
                modeIndicator.classList.remove('visible');

                if (nearPlanet) {
                    const data = planetData.find(p => p.name === nearPlanet.userData.name);
                    planetLabel.textContent = nearPlanet.userData.name;
                    planetLabel.style.color = '#' + data.color.toString(16).padStart(6, '0');
                    planetLabel.classList.add('visible');
                } else {
                    planetLabel.classList.remove('visible');
                }
            }
        }

        initScene();
        animate();
        initHandTracking();
    </script>
</body>
</html>
