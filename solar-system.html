<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Control Solar System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #webcam {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            border: 2px solid rgba(0, 255, 100, 0.3);
            transform: scaleX(-1);
            z-index: 100;
            object-fit: cover;
        }

        #canvas {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            z-index: 101;
            pointer-events: none;
            transform: scaleX(-1);
        }

        .hand-cursor {
            position: fixed;
            width: 50px;
            height: 50px;
            border: 3px solid #00ff66;
            border-radius: 50%;
            pointer-events: none;
            z-index: 200;
            transform: translate(-50%, -50%);
            transition: transform 0.05s, border-color 0.15s, box-shadow 0.15s;
            opacity: 0;
        }

        .hand-cursor.visible {
            opacity: 1;
        }

        .hand-cursor.pinching {
            border-color: #00ffaa;
            box-shadow: 0 0 30px rgba(0, 255, 170, 0.6);
            transform: translate(-50%, -50%) scale(0.6);
        }

        .hand-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: #00ff66;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 12px;
            font-size: 14px;
        }

        #instructions h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #00ff66;
        }

        #instructions p {
            margin: 8px 0;
            color: rgba(255, 255, 255, 0.8);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 300;
            text-align: center;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 255, 102, 0.2);
            border-top-color: #00ff66;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #planet-label {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
            text-shadow: 0 0 20px currentColor;
            letter-spacing: 4px;
        }

        #planet-label.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        <div>Loading Solar System...</div>
    </div>

    <div id="container"></div>

    <video id="webcam" autoplay playsinline></video>
    <canvas id="canvas"></canvas>

    <div class="hand-cursor" id="cursor"></div>

    <div id="planet-label"></div>

    <div id="instructions">
        <h2>üåå Solar System</h2>
        <p>ü§è <strong>Pinch</strong> to grab a planet</p>
        <p>‚úã <strong>Move</strong> while pinching to spin it</p>
        <p>ü§èü§è <strong>Two hands</strong> to zoom in/out</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <script>
        let scene, camera, renderer;
        let planets = [];
        let selectedPlanet = null;
        let solarSystemGroup;

        // Camera controls
        let targetCamX = 0, targetCamY = 30, targetCamZ = 50;
        let currentCamX = 0, currentCamY = 30, currentCamZ = 50;
        let targetLookAt = { x: 0, y: 0, z: 0 };

        // Hand tracking
        let hands = { left: null, right: null };
        let lastPinchPos = null;
        let lastTwoHandDist = null;

        const planetData = [
            { name: 'Sun', radius: 3, distance: 0, color: 0xffdd00, emissive: true, rotationSpeed: 0.001 },
            { name: 'Mercury', radius: 0.3, distance: 6, color: 0x8c7853, rotationSpeed: 0.01 },
            { name: 'Venus', radius: 0.5, distance: 9, color: 0xffc649, rotationSpeed: 0.008 },
            { name: 'Earth', radius: 0.55, distance: 12, color: 0x6b93d6, rotationSpeed: 0.01 },
            { name: 'Mars', radius: 0.4, distance: 16, color: 0xc1440e, rotationSpeed: 0.009 },
            { name: 'Jupiter', radius: 1.5, distance: 22, color: 0xd8ca9d, rotationSpeed: 0.02 },
            { name: 'Saturn', radius: 1.2, distance: 30, color: 0xead6b8, hasRings: true, rotationSpeed: 0.018 },
            { name: 'Uranus', radius: 0.8, distance: 38, color: 0xd1e7e7, rotationSpeed: 0.012 },
            { name: 'Neptune', radius: 0.75, distance: 45, color: 0x5b5ddf, rotationSpeed: 0.011 }
        ];

        function createPlanetTexture(color, isEarth = false, isJupiter = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Base color
            const baseColor = '#' + color.toString(16).padStart(6, '0');
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, 512, 256);

            // Add some variation
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 256;
                const r = Math.random() * 30 + 10;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${Math.random() > 0.5 ? 255 : 0}, ${Math.random() > 0.5 ? 255 : 0}, ${Math.random() > 0.5 ? 255 : 0}, 0.1)`;
                ctx.fill();
            }

            if (isEarth) {
                // Add continents
                ctx.fillStyle = '#2d5a27';
                ctx.beginPath();
                ctx.ellipse(150, 100, 60, 40, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(350, 80, 80, 50, 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(380, 160, 40, 50, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            if (isJupiter) {
                // Add bands
                for (let y = 0; y < 256; y += 20) {
                    ctx.fillStyle = y % 40 === 0 ? 'rgba(139, 90, 43, 0.3)' : 'rgba(210, 180, 140, 0.2)';
                    ctx.fillRect(0, y, 512, 10);
                }
                // Great red spot
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.ellipse(200, 130, 40, 25, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        }

        function initScene() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 50);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000008);
            document.getElementById('container').appendChild(renderer.domElement);

            // Stars
            const starGeo = new THREE.BufferGeometry();
            const starPos = new Float32Array(5000 * 3);
            for (let i = 0; i < 5000 * 3; i += 3) {
                starPos[i] = (Math.random() - 0.5) * 500;
                starPos[i + 1] = (Math.random() - 0.5) * 500;
                starPos[i + 2] = (Math.random() - 0.5) * 500;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 }));
            scene.add(stars);

            solarSystemGroup = new THREE.Group();

            // Create planets
            planetData.forEach((data, index) => {
                const group = new THREE.Group();

                // Planet sphere
                const geometry = new THREE.SphereGeometry(data.radius, 32, 32);
                let material;

                if (data.emissive) {
                    material = new THREE.MeshBasicMaterial({
                        map: createPlanetTexture(data.color),
                        color: data.color
                    });
                } else {
                    material = new THREE.MeshStandardMaterial({
                        map: createPlanetTexture(data.color, data.name === 'Earth', data.name === 'Jupiter'),
                        roughness: 0.8,
                        metalness: 0.1
                    });
                }

                const mesh = new THREE.Mesh(geometry, material);
                group.add(mesh);

                // Saturn's rings
                if (data.hasRings) {
                    const ringGeo = new THREE.RingGeometry(1.5, 2.5, 64);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: 0xc9b896,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.7
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 2;
                    group.add(ring);
                }

                // Position
                group.position.x = data.distance;
                group.userData = {
                    name: data.name,
                    baseDistance: data.distance,
                    rotationSpeed: data.rotationSpeed,
                    mesh: mesh
                };

                solarSystemGroup.add(group);
                planets.push(group);

                // Orbit line
                if (data.distance > 0) {
                    const orbitGeo = new THREE.BufferGeometry();
                    const orbitPoints = [];
                    for (let i = 0; i <= 64; i++) {
                        const angle = (i / 64) * Math.PI * 2;
                        orbitPoints.push(
                            Math.cos(angle) * data.distance,
                            0,
                            Math.sin(angle) * data.distance
                        );
                    }
                    orbitGeo.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints, 3));
                    const orbitMat = new THREE.LineBasicMaterial({ color: 0x333344, transparent: true, opacity: 0.3 });
                    const orbit = new THREE.Line(orbitGeo, orbitMat);
                    solarSystemGroup.add(orbit);
                }
            });

            scene.add(solarSystemGroup);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);

            const sunLight = new THREE.PointLight(0xffffff, 2, 200);
            sunLight.position.set(0, 0, 0);
            scene.add(sunLight);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Auto-rotate planets
            planets.forEach(planet => {
                if (!selectedPlanet || selectedPlanet !== planet) {
                    planet.children[0].rotation.y += planet.userData.rotationSpeed;
                }
            });

            // Smooth camera
            currentCamX += (targetCamX - currentCamX) * 0.05;
            currentCamY += (targetCamY - currentCamY) * 0.05;
            currentCamZ += (targetCamZ - currentCamZ) * 0.05;

            camera.position.set(currentCamX, currentCamY, currentCamZ);
            camera.lookAt(targetLookAt.x, targetLookAt.y, targetLookAt.z);

            renderer.render(scene, camera);
        }

        function screenToWorld(screenX, screenY) {
            const vector = new THREE.Vector3(
                (screenX / window.innerWidth) * 2 - 1,
                -(screenY / window.innerHeight) * 2 + 1,
                0.5
            );
            vector.unproject(camera);
            return vector;
        }

        function findNearestPlanet(screenX, screenY) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(
                (screenX / window.innerWidth) * 2 - 1,
                -(screenY / window.innerHeight) * 2 + 1
            );

            raycaster.setFromCamera(mouse, camera);

            let nearest = null;
            let nearestDist = Infinity;

            planets.forEach(planet => {
                const meshes = planet.children.filter(c => c.type === 'Mesh');
                const intersects = raycaster.intersectObjects(meshes);
                if (intersects.length > 0 && intersects[0].distance < nearestDist) {
                    nearestDist = intersects[0].distance;
                    nearest = planet;
                }
            });

            // If no direct hit, find closest planet to cursor
            if (!nearest) {
                planets.forEach(planet => {
                    const planetScreen = planet.position.clone().project(camera);
                    const px = (planetScreen.x + 1) / 2 * window.innerWidth;
                    const py = (-planetScreen.y + 1) / 2 * window.innerHeight;
                    const dist = Math.sqrt(Math.pow(px - screenX, 2) + Math.pow(py - screenY, 2));

                    // Only select if within reasonable distance (based on planet size)
                    const threshold = 80 + planet.userData.mesh.geometry.parameters.radius * 20;
                    if (dist < threshold && dist < nearestDist) {
                        nearestDist = dist;
                        nearest = planet;
                    }
                });
            }

            return nearest;
        }

        async function initHandTracking() {
            const video = document.getElementById('webcam');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const loading = document.getElementById('loading');
            const cursor = document.getElementById('cursor');
            const planetLabel = document.getElementById('planet-label');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                video.srcObject = stream;
                await video.play();
            } catch (err) {
                loading.innerHTML = '‚ùå Camera access needed';
                return;
            }

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            const mpHands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            mpHands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            mpHands.onResults((results) => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                hands.left = null;
                hands.right = null;

                if (results.multiHandLandmarks && results.multiHandedness) {
                    for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                        const landmarks = results.multiHandLandmarks[i];
                        const label = results.multiHandedness[i].label;

                        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: '#00ff66', lineWidth: 2 });

                        if (label === 'Left') {
                            hands.right = landmarks;
                        } else {
                            hands.left = landmarks;
                        }
                    }
                }

                processHands(cursor, planetLabel);
            });

            loading.style.display = 'none';

            const cam = new Camera(video, {
                onFrame: async () => await mpHands.send({ image: video }),
                width: 640,
                height: 480
            });
            cam.start();
        }

        function getPinchCenter(hand) {
            const thumb = hand[4];
            const index = hand[8];
            return {
                x: (thumb.x + index.x) / 2,
                y: (thumb.y + index.y) / 2
            };
        }

        function getPinchDistance(hand) {
            const thumb = hand[4];
            const index = hand[8];
            return Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
        }

        function processHands(cursor, planetLabel) {
            const leftHand = hands.left;
            const rightHand = hands.right;

            // Use first available hand for cursor
            const activeHand = leftHand || rightHand;

            if (activeHand) {
                const pos = getPinchCenter(activeHand);
                const screenX = (1 - pos.x) * window.innerWidth;
                const screenY = pos.y * window.innerHeight;
                const isPinching = getPinchDistance(activeHand) < 0.07;

                cursor.style.left = screenX + 'px';
                cursor.style.top = screenY + 'px';
                cursor.classList.add('visible');
                cursor.classList.toggle('pinching', isPinching);

                // Check for second hand (zoom)
                const secondHand = leftHand && rightHand ? (activeHand === leftHand ? rightHand : leftHand) : null;
                const secondPinching = secondHand && getPinchDistance(secondHand) < 0.07;

                // Two hands = zoom
                if (isPinching && secondPinching) {
                    const pos1 = getPinchCenter(leftHand);
                    const pos2 = getPinchCenter(rightHand);
                    const dist = Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));

                    if (lastTwoHandDist !== null) {
                        const delta = (lastTwoHandDist - dist) * 100;
                        targetCamZ = Math.max(15, Math.min(100, targetCamZ + delta));
                        targetCamY = targetCamZ * 0.6;
                    }

                    lastTwoHandDist = dist;
                    lastPinchPos = null;
                    selectedPlanet = null;
                    planetLabel.classList.remove('visible');
                }
                // Single hand pinch = grab planet
                else if (isPinching) {
                    if (!selectedPlanet) {
                        selectedPlanet = findNearestPlanet(screenX, screenY);
                        if (selectedPlanet) {
                            planetLabel.textContent = selectedPlanet.userData.name;
                            planetLabel.style.color = '#' + planetData.find(p => p.name === selectedPlanet.userData.name).color.toString(16).padStart(6, '0');
                            planetLabel.classList.add('visible');
                        }
                    }

                    if (selectedPlanet && lastPinchPos) {
                        const deltaX = (pos.x - lastPinchPos.x) * 8;
                        const deltaY = (pos.y - lastPinchPos.y) * 8;

                        // Rotate the selected planet
                        selectedPlanet.children[0].rotation.y -= deltaX;
                        selectedPlanet.children[0].rotation.x += deltaY;
                    }

                    lastPinchPos = pos;
                    lastTwoHandDist = null;
                }
                // No pinch
                else {
                    // Show planet name on hover
                    const hoveredPlanet = findNearestPlanet(screenX, screenY);
                    if (hoveredPlanet) {
                        planetLabel.textContent = hoveredPlanet.userData.name;
                        planetLabel.style.color = '#' + planetData.find(p => p.name === hoveredPlanet.userData.name).color.toString(16).padStart(6, '0');
                        planetLabel.classList.add('visible');
                    } else {
                        planetLabel.classList.remove('visible');
                    }

                    selectedPlanet = null;
                    lastPinchPos = null;
                    lastTwoHandDist = null;
                }
            } else {
                cursor.classList.remove('visible', 'pinching');
                selectedPlanet = null;
                lastPinchPos = null;
                lastTwoHandDist = null;
                planetLabel.classList.remove('visible');
            }
        }

        initScene();
        animate();
        initHandTracking();
    </script>
</body>
</html>
